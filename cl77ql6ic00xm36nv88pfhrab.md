# Introduction to Software Engineering

# Why? ü§î
The economies of ALL developed nations are dependent on software.
More and more systems are software controlled and a Well-executed software development methodology helps teams significantly improve the quality of their software at each release. Not only that, it allows teams to adapt to change quickly.

> Usually, folks skip this "WHY" part but it's important to know why you are studying it and how it solves a problem.

# What is software? üë®‚Äçüíª
Computer programs and associated documentation such as requirements, design models, and user manuals.
Software products may be developed for a particular customer or may be developed for a general market.
Software products may be

- **Generic -** developed to be sold to a range of different customers e.g. PC software such as Excel or Word.

- **Bespoke (custom) -** developed for a single customer according to their specification.

New software can be created by developing new programs, configuring generic software systems, or reusing existing software.

# What is software engineering?
**Software engineering** is an engineering discipline that is concerned with all aspects of software production and **software engineers** should adopt a systematic and organized approach to their work and use appropriate tools and techniques depending on the problem to be solved, and the development constraints, and the resources available.

# What is the difference between?
## Software Engineering Vs Computer Science
Computer science is concerned with theory and fundamentals, software engineering is concerned with the practicalities of developing and delivering useful software.
## Software Engineering Vs System Engineering
System engineering is concerned with all aspects of computer-based systems development including hardware, software, and process engineering. Software engineering is part of this process concerned with developing the software infrastructure, control, applications, and databases in the system.

# Software Costs ü§ë
- Software costs often dominate computer system costs. The costs of software on a PC are often greater than the hardware cost. Roughly 60% of costs are development costs, and 40% are testing costs.

- Software costs more to maintain than it does to develop. For systems with long life, maintenance costs may be several times development costs.

- Software engineering is concerned with cost-effective software development.

- Distribution of costs depends on the **development model** that is used.

<iframe src="https://giphy.com/embed/kPtv3UIPrv36cjxqLs" width="480" height="270" frameBorder="0" class="giphy-embed" allowFullScreen></iframe><p><a href="https://giphy.com/gifs/nba-celebrity-kPtv3UIPrv36cjxqLs">via GIPHY</a></p>

# What is a software process?
A set of activities whose goal is the development or evolution of software.
Generic activities in all software processes are:
- **Specification -** What the system should do and its development constraints.
- **Development -** Production of the software system.
- **Validation -** Checking that the software is what the customer wants.
- **Evolution -** Changing the software in response to changing demands.

# What is a software process model?
The process of dividing software development work into distinct phases to improve design, product management, and project management.

## Generic Process Models
- Waterfall üåä
- Iterative development
- Component-based software engineering

> We will discuss these models in brief in other blogs of this series.

# What is CASE (Computer-Aided Software Engineering)?
Software systems that are intended to provide automated support for software process activities.
**CASE** systems are often used for method support.

**Upper-CASE** ‚òùÔ∏è
- Tools to support the early process activities of requirements and design.

**Lower-CASE** üëá
- Tools to support later activities such as programming, debugging, and testing.

# Attributes of Good Software ‚ú®
The software should deliver the required functionality and performance to the user and should be maintainable, dependable, and acceptable.

- Maintainability
- Dependability
- Efficiency
- Acceptability

# Challenges Faced by a Software Engineer

**Heterogeneity**
- Developing techniques for building software that can cope with heterogeneous platforms and execution environments.

**Delivery** üöö
- Developing techniques that lead to faster delivery of software.

**Trust** ü§®
- Developing techniques that demonstrate that software can be trusted by its users.

<iframe src="https://giphy.com/embed/l2YWFxG9GxXk8A7w4" width="480" height="360" frameBorder="0" class="giphy-embed" allowFullScreen></iframe><p><a href="https://giphy.com/gifs/obama-barack-obama-potus-l2YWFxG9GxXk8A7w4">via GIPHY</a></p>


# Nature of Software
Software plays a dual role:- **Product** and **Vehicle**

1. **As a product:** 
  -  It delivers the computing potential across networks of Hardware.
  -  It enables the Hardware to deliver the expected functionality.
  -  It acts as an information transformer because it produces, manages, acquires, modifies, displays, or transmits information.

1. **As a vehicle:**
  -  It provides system functionality (e.g., payroll system)
  -  It controls other software (e.g., an operating system)
  -  It helps build other software (e.g., software tools)

The software delivers the information
- Transform personal information in a local context
- Manages business information 
- Gateway to worldwide information network

# Hardware Failure Rate üìâ
## How bathtub curve describe hardware failure rate?

The bathtub curve is generated by mapping the rate of early "**infant mortality**" failures when first introduced, the rate of random failures with a constant failure rate during its "**useful life**", and finally the rate of "**wear out**" failures as the product exceeds its design lifetime.

![ht21_1.gif](https://cdn.hashnode.com/res/hashnode/image/upload/v1659422235044/Kc-Q5EveI.gif align="center")
<iframe src="https://giphy.com/embed/l0HlPhCGQuCxNpHI4" width="480" height="270" frameBorder="0" class="giphy-embed" allowFullScreen></iframe><p><a href="https://giphy.com/gifs/southparkgifs-l0HlPhCGQuCxNpHI4">via GIPHY</a></p>

## Wear vs. Deterioration

![imageedit_1_5079605187.jpg](https://cdn.hashnode.com/res/hashnode/image/upload/v1659422442173/TpQ6iUiQJ.jpg align="left")

# Software Applications üì±

1. **System software:** System Software is necessary to manage the computer resources and support the execution of application programs. such as compilers, editors, and file management utilities.

1. **Application software:** Application software is designed to fulfill the user‚Äôs requirement by interacting with the user directly, stand-alone programs for specific needs.

1. **Engineering/scientific software:** Scientific and engineering software satisfies the needs of a scientific or engineering user to perform enterprise-specific tasks. Characterized by ‚Äúnumber crunching‚Äù algorithms such as automotive stress analysis, molecular biology, orbital dynamics, etc.

1. **Embedded software:** This type of software is embedded into the hardware normally in the Read-Only Memory (ROM) as a part of a large system and is used to support certain functionality under the control conditions residing within a product or system. (keypad control of a microwave oven, digital function of dashboard display in a car).

1. **Product-line software:** focus on a limited marketplace to address the mass consumer market. (word processing, graphics, database management).

1. **WebApps (Web applications):** Networking Software provides the required support necessary for computers to interact with each other and with data storage facilities. The networking software is also used when software is running on a network of computers (such as the World Wide Web).

1. **AI:** Software like expert systems, decision support systems, pattern recognition software, artificial neural networks, etc.

1. **Open world computing:** pervasive, ubiquitous, distributed computing due to wireless networking. How to allow mobile devices, personal computers, and enterprise systems to communicate across a vast network.

1. **Open source:** "free" source code open to the computing community.

Thank you so much for taking your valuable time for reading

I took the initiative to learn in public and share my work with others. I tried my level best in squeezing as much information as possible in the easiest manner. Hope you learnt something new today :)

In the next part of this blog, we will study about **Software Development Models & Architecture**. üëá

https://ikunalsingh.hashnode.dev/software-development-models-architecture

Any feedback for further improvement will be highly appreciated!
<iframe src="https://giphy.com/embed/uqmtVo5zcIBXJq1rGX" width="480" height="400" frameBorder="0" class="giphy-embed" allowFullScreen></iframe><p><a href="https://giphy.com/gifs/martin-uqmtVo5zcIBXJq1rGX">via GIPHY</a></p>


 




 






















